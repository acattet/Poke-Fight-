{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { wait, magic, heal, attack, playerStats, opponentStats } from 'shared';\nimport { useEffect, useState } from 'react';\nexport const useBattleSequence = sequence => {\n  _s();\n\n  const [turn, setTurn] = useState(0);\n  const [inSequence, setInSequence] = useState(false);\n  const [playerHealth, setPlayerHealth] = useState(playerStats.maxHealth);\n  const [opponentHealth, setOpponentHealth] = useState(opponentStats.maxHealth);\n  const [announcerMessage, setAnnouncerMessage] = useState('');\n  const [playerAnimation, setPlayerAnimation] = useState('static');\n  const [opponentAnimation, setOpponentAnimation] = useState('static');\n  useEffect(() => {\n    const {\n      mode,\n      turn\n    } = sequence;\n\n    if (mode) {\n      const attacker = turn === 0 ? playerStats : opponentStats;\n      const receiver = turn === 0 ? opponentStats : playerStats;\n\n      switch (mode) {\n        case 'attack':\n          {\n            const damage = attack({\n              attacker,\n              receiver\n            });\n\n            (async () => {\n              setInSequence(true);\n              setAnnouncerMessage(`${attacker.name} has chosen to attack!`);\n              await wait(1000);\n              turn === 0 ? setPlayerAnimation('attack') : setOpponentAnimation('attack');\n              await wait(100);\n              turn === 0 ? setPlayerAnimation('static') : setOpponentAnimation('static');\n              await wait(500);\n              turn === 0 ? setOpponentAnimation('damage') : setPlayerAnimation('damage');\n              await wait(750);\n              turn === 0 ? setOpponentAnimation('static') : setPlayerAnimation('static');\n              setAnnouncerMessage(`${receiver.name} felt that!`);\n              turn === 0 ? setOpponentHealth(h => h - damage > 0 ? h - damage : 0) : setPlayerHealth(h => h - damage > 0 ? h - damage : 0); // We don't want a negative HP.\n\n              await wait(2000);\n              setAnnouncerMessage(`Now it's ${receiver.name} turn!`);\n              await wait(1500);\n              setTurn(turn === 0 ? 1 : 0);\n              setInSequence(false);\n            })();\n\n            break;\n          }\n\n        case 'magic':\n          {\n            const damage = magic({\n              attacker,\n              receiver\n            });\n\n            (async () => {\n              setInSequence(true);\n              setAnnouncerMessage(`${attacker.name} has cast a spell!`);\n              await wait(1000);\n              turn === 0 ? setPlayerAnimation('magic') : setOpponentAnimation('magic');\n              await wait(1000);\n              turn === 0 ? setPlayerAnimation('static') : setOpponentAnimation('static');\n              await wait(500);\n              turn === 0 ? setOpponentAnimation('damage') : setPlayerAnimation('damage');\n              await wait(750);\n              turn === 0 ? setOpponentAnimation('static') : setPlayerAnimation('static');\n              setAnnouncerMessage(`${receiver.name} doesn't know what hit them!`);\n              turn === 0 ? setOpponentHealth(h => h - damage > 0 ? h - damage : 0) : setPlayerHealth(h => h - damage > 0 ? h - damage : 0); // We don't want a negative HP.\n\n              await wait(2500);\n              setAnnouncerMessage(`Now it's ${receiver.name}'s turn!`);\n              await wait(1500);\n              setTurn(turn === 0 ? 1 : 0);\n              setInSequence(false);\n            })();\n\n            break;\n          }\n\n        case 'heal':\n          {\n            const recovered = heal({\n              receiver: attacker\n            });\n\n            (async () => {\n              setInSequence(true);\n              setAnnouncerMessage(`${attacker.name} has chosen to heal!`);\n              await wait(1000);\n              turn === 0 ? setPlayerAnimation('magic') : setOpponentAnimation('magic');\n              await wait(1000);\n              turn === 0 ? setPlayerAnimation('static') : setOpponentAnimation('static');\n              await wait(500);\n              setAnnouncerMessage(`${attacker.name} has recovered health.`);\n              turn === 0 ? setPlayerHealth(h => h + recovered <= attacker.maxHealth ? h + recovered : attacker.maxHealth) : setOpponentHealth(h => h + recovered <= attacker.maxHealth ? h + recovered : attacker.maxHealth); // We don't want to set HP more than the max\n\n              await wait(2500);\n              setAnnouncerMessage(`Now it's ${receiver.name}'s turn!`);\n              await wait(1500);\n              setTurn(turn === 0 ? 1 : 0);\n              setInSequence(false);\n            })();\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    }\n  }, [sequence]);\n  return {\n    turn,\n    inSequence,\n    playerHealth,\n    opponentHealth,\n    playerAnimation,\n    opponentAnimation,\n    announcerMessage\n  };\n};\n\n_s(useBattleSequence, \"Sy7cYyOgiV0CxzDhdHyPdjVVx/Q=\");","map":{"version":3,"sources":["/Users/austinfb/Documents/Coding/projects/Poke-Fight-/src/hooks/useBattleSequence.js"],"names":["wait","magic","heal","attack","playerStats","opponentStats","useEffect","useState","useBattleSequence","sequence","turn","setTurn","inSequence","setInSequence","playerHealth","setPlayerHealth","maxHealth","opponentHealth","setOpponentHealth","announcerMessage","setAnnouncerMessage","playerAnimation","setPlayerAnimation","opponentAnimation","setOpponentAnimation","mode","attacker","receiver","damage","name","h","recovered"],"mappings":"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","sourcesContent":["import {\n  wait,\n  magic,\n  heal,\n  attack,\n  playerStats,\n  opponentStats,\n} from 'shared';\nimport { useEffect, useState } from 'react';\n\nexport const useBattleSequence = sequence => {\n  const [turn, setTurn] = useState(0);\n  const [inSequence, setInSequence] = useState(false);\n\n  const [playerHealth, setPlayerHealth] = useState(playerStats.maxHealth);\n  const [opponentHealth, setOpponentHealth] = useState(\n    opponentStats.maxHealth,\n  );\n\n  const [announcerMessage, setAnnouncerMessage] = useState('');\n\n  const [playerAnimation, setPlayerAnimation] = useState('static');\n  const [opponentAnimation, setOpponentAnimation] = useState('static');\n\n  useEffect(() => {\n    const { mode, turn } = sequence;\n\n    if (mode) {\n      const attacker = turn === 0 ? playerStats : opponentStats;\n      const receiver = turn === 0 ? opponentStats : playerStats;\n\n      switch (mode) {\n        case 'attack': {\n          const damage = attack({ attacker, receiver });\n\n          (async () => {\n            setInSequence(true);\n            setAnnouncerMessage(`${attacker.name} has chosen to attack!`);\n            await wait(1000);\n\n            turn === 0\n              ? setPlayerAnimation('attack')\n              : setOpponentAnimation('attack');\n            await wait(100);\n\n            turn === 0\n              ? setPlayerAnimation('static')\n              : setOpponentAnimation('static');\n            await wait(500);\n\n            turn === 0\n              ? setOpponentAnimation('damage')\n              : setPlayerAnimation('damage');\n            await wait(750);\n\n            turn === 0\n              ? setOpponentAnimation('static')\n              : setPlayerAnimation('static');\n            setAnnouncerMessage(`${receiver.name} felt that!`);\n            turn === 0\n              ? setOpponentHealth(h => (h - damage > 0 ? h - damage : 0))\n              : setPlayerHealth(h => (h - damage > 0 ? h - damage : 0)); // We don't want a negative HP.\n            await wait(2000);\n\n            setAnnouncerMessage(`Now it's ${receiver.name} turn!`);\n            await wait(1500);\n\n            setTurn(turn === 0 ? 1 : 0);\n            setInSequence(false);\n          })();\n\n          break;\n        }\n\n        case 'magic': {\n          const damage = magic({ attacker, receiver });\n\n          (async () => {\n            setInSequence(true);\n            setAnnouncerMessage(`${attacker.name} has cast a spell!`);\n            await wait(1000);\n\n            turn === 0\n              ? setPlayerAnimation('magic')\n              : setOpponentAnimation('magic');\n            await wait(1000);\n\n            turn === 0\n              ? setPlayerAnimation('static')\n              : setOpponentAnimation('static');\n            await wait(500);\n\n            turn === 0\n              ? setOpponentAnimation('damage')\n              : setPlayerAnimation('damage');\n            await wait(750);\n\n            turn === 0\n              ? setOpponentAnimation('static')\n              : setPlayerAnimation('static');\n            setAnnouncerMessage(\n              `${receiver.name} doesn't know what hit them!`,\n            );\n            turn === 0\n              ? setOpponentHealth(h => (h - damage > 0 ? h - damage : 0))\n              : setPlayerHealth(h => (h - damage > 0 ? h - damage : 0)); // We don't want a negative HP.\n            await wait(2500);\n\n            setAnnouncerMessage(`Now it's ${receiver.name}'s turn!`);\n            await wait(1500);\n\n            setTurn(turn === 0 ? 1 : 0);\n            setInSequence(false);\n          })();\n\n          break;\n        }\n\n        case 'heal': {\n          const recovered = heal({ receiver: attacker });\n\n          (async () => {\n            setInSequence(true);\n            setAnnouncerMessage(`${attacker.name} has chosen to heal!`);\n            await wait(1000);\n\n            turn === 0\n              ? setPlayerAnimation('magic')\n              : setOpponentAnimation('magic');\n            await wait(1000);\n\n            turn === 0\n              ? setPlayerAnimation('static')\n              : setOpponentAnimation('static');\n            await wait(500);\n\n            setAnnouncerMessage(`${attacker.name} has recovered health.`);\n            turn === 0\n              ? setPlayerHealth(h =>\n                  h + recovered <= attacker.maxHealth\n                    ? h + recovered\n                    : attacker.maxHealth,\n                )\n              : setOpponentHealth(h =>\n                  h + recovered <= attacker.maxHealth\n                    ? h + recovered\n                    : attacker.maxHealth,\n                ); // We don't want to set HP more than the max\n            await wait(2500);\n\n            setAnnouncerMessage(`Now it's ${receiver.name}'s turn!`);\n            await wait(1500);\n\n            setTurn(turn === 0 ? 1 : 0);\n            setInSequence(false);\n          })();\n\n          break;\n        }\n\n        default:\n          break;\n      }\n    }\n  }, [sequence]);\n\n  return {\n    turn,\n    inSequence,\n    playerHealth,\n    opponentHealth,\n    playerAnimation,\n    opponentAnimation,\n    announcerMessage,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}